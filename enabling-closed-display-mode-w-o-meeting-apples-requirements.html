<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=description content="EDIT: I have heavily edited this question after making some significant new discoveries and the question not having any answers yet. Historically/AFAIK, keeping your Mac awake while in closed-display mode and not meeting Apple's requirements, has only been possible with a kernel extension (kext), or a command run as root. Recently however, I have discovered"><meta name=author content="Reinaldo Massengill"><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=robots content="index,follow,noarchive"><link rel=stylesheet href=https://assets.cdnweb.info/hugo/base16/css/style.css type=text/css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type=text/css><link rel=alternate href=./index.xml type=application/rss+xml title=WinkDash><title>Enabling Closed-Display Mode w/o Meeting Apple's Requirements - WinkDash</title></head><body><header><div class="container clearfix"><a class=path href=./index.html>[WinkDash]</a>
<span class=caret># _</span><div class=right></div></div></header><div class=container><main role=main class=article><article class=single itemscope itemtype=http://schema.org/BlogPosting><div class=meta><span class=key>published on</span>
<span class=val><time itemprop=datePublished datetime=2024-07-07>July 07, 2024</time></span>
<span class=key>in</span>
<span class=val><a href=./categories/blog>blog</a></span></div><h1 class=headline itemprop=headline>Enabling Closed-Display Mode w/o Meeting Apple's Requirements</h1><section class=body itemprop=articleBody><p><strong>EDIT:</strong> I have heavily edited this question after making some significant new discoveries and the question not having any answers yet.</p><p>Historically/AFAIK, keeping your Mac awake while in closed-display mode and not meeting <a href=# rel="nofollow noreferrer">Apple's requirements</a>, has only been possible with a <a href=# rel="nofollow noreferrer">kernel extension</a> (kext), or a <a href=# rel="nofollow noreferrer">command</a> run as root. Recently however, I have discovered that there must be another way. I could really use some help figuring out how to get this working for use in a (100% free, no IAP) sandboxed Mac App Store (MAS) compatible app.</p><p>I have confirmed that some other MAS apps are able to do this, and it looks like they might be writing <code>YES</code> to a key named <code>clamshellSleepDisabled</code>. Or perhaps there's some other trickery involved that causes the key value to be set to YES? I found the function in <a href=# rel="nofollow noreferrer">IOPMrootDomain.cpp</a>:</p><pre><code>void IOPMrootDomain::setDisableClamShellSleep( bool val ) { if (gIOPMWorkLoop-&gt;inGate() == false) { gIOPMWorkLoop-&gt;runAction( OSMemberFunctionCast(IOWorkLoop::Action, this, &amp;IOPMrootDomain::setDisableClamShellSleep), (OSObject *)this, (void *)val); return; } else { DLOG("setDisableClamShellSleep(%x)\n", (uint32_t) val); if ( clamshellSleepDisabled != val ) { clamshellSleepDisabled = val; // If clamshellSleepDisabled is reset to 0, reevaluate if // system need to go to sleep due to clamshell state if ( !clamshellSleepDisabled &amp;&amp; clamshellClosed) handlePowerNotification(kLocalEvalClamshellCommand); } } } </code></pre><p>I'd like to give this a try and see if that's all it takes, but I don't really have any idea about how to go about calling this function. It's certainly not a part of the <a href=# rel="nofollow noreferrer">IOPMrootDomain</a> documentation, and I can't seem to find any helpful example code for functions that are in the IOPMrootDomain documentation, such as <code>setAggressiveness</code> or <code>setPMAssertionLevel</code>. Here's some evidence of what's going on behind the scenes according to Console:</p><p><a href=# rel="nofollow noreferrer"><img src=https://cdn.statically.io/img/i.stack.imgur.com/axe9T.png alt="Image of message logs from Console.app" style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>I've had a tiny bit of experience working with IOMProotDomain via adapting some of <a href=# rel="nofollow noreferrer">ControlPlane</a>'s source for another project, but I'm at a loss for how to get started on this. Any help would be greatly appreciated. Thank you!</p><p><strong>EDIT: With @pmdj's contribution/answer, this has been solved!</strong></p><p>Full example project: <a href=# rel="nofollow noreferrer">https://github.com/x74353/CDMManager</a></p><p>This ended up being surprisingly simple/straightforward:</p><p><strong>1. Import header:</strong></p><pre><code>#import &lt;IOKit/pwr_mgt/IOPMLib.h&gt; </code></pre><p><strong>2. Add this function in your implementation file:</strong></p><pre><code>IOReturn RootDomain_SetDisableClamShellSleep (io_connect_t root_domain_connection, bool disable) { uint32_t num_outputs = 0; uint32_t input_count = 1; uint64_t input[input_count]; input[0] = (uint64_t) { disable ? 1 : 0 }; return IOConnectCallScalarMethod(root_domain_connection, kPMSetClamshellSleepState, input, input_count, NULL, &amp;num_outputs); } </code></pre><p><strong>3. Use the following to call the above function from somewhere else in your implementation:</strong></p><pre><code>io_connect_t connection = IO_OBJECT_NULL; io_service_t pmRootDomain = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOPMrootDomain")); IOServiceOpen (pmRootDomain, current_task(), 0, &amp;connection); // 'enable' is a bool you should assign a YES or NO value to prior to making this call RootDomain_SetDisableClamShellSleep(connection, enable); IOServiceClose(connection); </code></pre><span class=d-none itemprop=commentCount>2</span><h2 class=mb0 data-answercount=1>1 Answer</h2><p>I have no personal experience with the PM root domain, but I do have extensive experience with IOKit, so here goes:</p><ul><li>You want <code>IOPMrootDomain::setDisableClamShellSleep()</code> to be called.</li><li>A code search for sites calling <code>setDisableClamShellSleep()</code> quickly reveals a location in <code>RootDomainUserClient::externalMethod()</code>, in the file <code>iokit/Kernel/RootDomainUserClient.cpp</code>. This is certainly promising, as <code>externalMethod()</code> is what gets called in response to user space programs calling the <code>IOConnectCall*()</code> family of functions.</li></ul><p>Let's dig in:</p><pre><code>IOReturn RootDomainUserClient::externalMethod( uint32_t selector, IOExternalMethodArguments * arguments, IOExternalMethodDispatch * dispatch __unused, OSObject * target __unused, void * reference __unused ) { IOReturn ret = kIOReturnBadArgument; switch (selector) { … … … case kPMSetClamshellSleepState: fOwner-&gt;setDisableClamShellSleep(arguments-&gt;scalarInput[0] ? true : false); ret = kIOReturnSuccess; break; … </code></pre><p>So, to invoke <code>setDisableClamShellSleep()</code> you'll need to:</p><li>Open a user client connection to <code>IOPMrootDomain</code>. This looks straightforward, because:<ul><li>Upon inspection, <code>IOPMrootDomain</code> has an <code>IOUserClientClass</code> property of <code>RootDomainUserClient</code>, so <code>IOServiceOpen()</code> from user space will by default create an <code>RootDomainUserClient</code> instance.</li><li><code>IOPMrootDomain</code> does not override the <code>newUserClient</code> member function, so there are no access controls there.</li><li><code>RootDomainUserClient::initWithTask()</code> does not appear to place any restrictions (e.g. root user, code signing) on the connecting user space process.</li><li>So it should simply be a case of running this code in your program:</li></ul></li><pre><code> io_connect_t connection = IO_OBJECT_NULL; IOReturn ret = IOServiceOpen( root_domain_service, current_task(), 0, // user client type, ignored &amp;connection); </code></pre><li>Call the appropriate external method.<ul><li>From the code excerpt earlier on, we know that the selector must be <code>kPMSetClamshellSleepState</code>.</li><li><code>arguments->scalarInput[0]</code> being zero will call <code>setDisableClamShellSleep(false)</code>, while a nonzero value will call <code>setDisableClamShellSleep(true)</code>.</li><li>This amounts to:</li></ul></li><pre><code>IOReturn RootDomain_SetDisableClamShellSleep(io_connect_t root_domain_connection, bool disable) { uint32_t num_outputs = 0; uint64_t inputs[] = { disable ? 1 : 0 }; return IOConnectCallScalarMethod( root_domain_connection, kPMSetClamshellSleepState, &amp;inputs, 1, // 1 = length of array 'inputs' NULL, &amp;num_outputs); } </code></pre><li>When you're done with your <code>io_connect_t</code> handle, don't forget to <code>IOServiceClose()</code> it.</li><p>This should let you toggle clamshell sleep on or off. Note that there does not appear to be any provision for automatically resetting the value to its original state, so if your program crashes or exits without cleaning up after itself, whatever state was last set will remain. This might not be great from a user experience perspective, so perhaps try to defend against it somehow, for example in a crash handler.</p><span class=d-none itemprop=commentCount>2</span><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmirpJawrLvVnqmfpJ%2Bse6S7zGiorp2jqbawutJobHJtaWl%2Bc3%2BOnqWampyeu6h5wqWmrJ2UYrGqv8%2BlmLJlnaSxpnnWZqZmpZWawaq6xmaYqaicmsBuvsSqrKKqlaKyr8DS</p></section></article></main></div><footer><div class=container><span class=copyright>&copy; 2024 WinkDash - <a rel=license href=http://creativecommons.org/licenses/by/4.0/>CC BY 4.0</a></span></div></footer><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>